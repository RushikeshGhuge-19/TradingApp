"""
DSL Backtest Engine - Executes strategies defined via Rule DSL
Integrates with frontend Strategy Builder for universal strategy execution
"""

from typing import List, Dict, Optional, Any, Callable
from datetime import datetime, date, timedelta
import logging
import pandas as pd
import numpy as np
import yfinance as yf

logger = logging.getLogger(__name__)


class TradeData:
    """Represents a single executed trade"""
    def __init__(
        self,
        entry_time: datetime,
        entry_price: float,
        direction: str,  # 'LONG' or 'SHORT'
        quantity: int,
        exit_time: Optional[datetime] = None,
        exit_price: Optional[float] = None,
        exit_reason: Optional[str] = None,
        profit_loss: float = 0.0,
        charges: float = 0.0,
    ):
        self.entry_time = entry_time
        self.entry_price = entry_price
        self.direction = direction
        self.quantity = quantity
        self.exit_time = exit_time
        self.exit_price = exit_price
        self.exit_reason = exit_reason
        self.profit_loss = profit_loss
        self.charges = charges

    def to_dict(self) -> Dict[str, Any]:
        return {
            'entry_time': self.entry_time.isoformat() if self.entry_time else None,
            'entry_price': self.entry_price,
            'direction': self.direction,
            'quantity': self.quantity,
            'exit_time': self.exit_time.isoformat() if self.exit_time else None,
            'exit_price': self.exit_price,
            'exit_reason': self.exit_reason,
            'profit_loss': self.profit_loss,
            'charges': self.charges,
        }


class DSLBacktestEngine:
    """
    Executes strategies compiled from Strategy DSL.
    
    Accepts:
    - CompiledStrategy: Generated by ruleCompiler.ts
    - Strategy metadata: Sizing, risk management, execution settings
    
    Outputs:
    - Trade history
    - Equity curve
    - Performance metrics
    """

    def __init__(
        self,
        compiled_strategy: Dict[str, Any],
        strategy_config: Dict[str, Any],
    ):
        """
        Initialize DSL backtest engine.
        
        Args:
            compiled_strategy: Output from ruleCompiler.ts
                {
                    'requiredLookback': int,
                    'evaluate': Callable function,
                    'indicators': Dict[str, List[float]],
                }
            strategy_config: Strategy metadata
                {
                    'capital': float,
                    'timeframe': str,
                    'symbols': List[str],
                    'risk': {...},
                    'execution': {...},
                }
        """
        self.compiled_strategy = compiled_strategy
        self.strategy_config = strategy_config

        # Extract config
        self.initial_capital = strategy_config.get('capital', 100000)
        self.timeframe = strategy_config.get('timeframe', '15m')
        self.symbols = strategy_config.get('symbols', ['NIFTYBANK.NS'])
        self.risk_config = strategy_config.get('risk', {})
        self.exec_config = strategy_config.get('execution', {})

        # Runtime state
        self.trades: List[TradeData] = []
        self.equity_curve: List[Dict] = []
        self.current_equity = self.initial_capital
        self.positions: Dict[str, Dict] = {}  # {symbol: {direction, entry_price, entry_time, ...}}
        self.highest_equity = self.initial_capital
        self.lowest_equity = self.initial_equity

    def fetch_candles(self, symbol: str, start_date: date, end_date: date) -> pd.DataFrame:
        """Fetch historical candles from Yahoo Finance"""
        try:
            end_fetch = end_date + timedelta(days=1)
            df = yf.download(
                tickers=symbol,
                start=start_date,
                end=end_fetch,
                interval=self.timeframe,
                progress=False,
                threads=False,
            )

            if df is None or df.empty:
                logger.warning(f"No candles for {symbol} {start_date}-{end_date}")
                return pd.DataFrame()

            # Handle multi-index columns
            if isinstance(df.columns, pd.MultiIndex):
                df = df.droplevel(1, axis=1)

            # Ensure lowercase columns
            df.columns = df.columns.str.lower()
            return df

        except Exception as exc:
            logger.error(f"Error fetching candles: {exc}")
            return pd.DataFrame()

    def _calculate_position_size(self, current_price: float, bar_idx: int) -> int:
        """Calculate position quantity based on sizing config"""
        sizing = self.risk_config.get('sizing', {})
        sizing_type = sizing.get('type', 'fixed_lot')

        if sizing_type == 'fixed_lot':
            return sizing.get('lots', 1)
        elif sizing_type == 'percent_capital':
            percent = sizing.get('percent', 2)
            risk_amount = self.current_equity * (percent / 100)
            sl_config = self.risk_config.get('sl', {})
            sl_value = sl_config.get('value', 20)
            quantity = int(risk_amount / (current_price * sl_value / 100))
            return max(quantity, 1)
        elif sizing_type == 'fixed_quantity':
            return sizing.get('quantity', 100)
        elif sizing_type == 'dynamic':
            # ATR-based sizing
            atr_mult = sizing.get('atrMultiplier', 1)
            # Would need ATR from indicators
            return int(self.current_equity / (current_price * 100)) * atr_mult
        else:
            return 1

    def _calculate_charges(self, entry_price: float, exit_price: float, quantity: int) -> float:
        """Calculate total charges/fees"""
        exec_config = self.exec_config.get('charges', {})
        mode = exec_config.get('mode', 'fixed')

        if mode == 'fixed':
            return exec_config.get('fixedCharge', 50)
        elif mode == 'components':
            comps = exec_config.get('components', {})
            total = 0
            # Per trade costs
            total += comps.get('brokerage', 0)
            total += comps.get('exchange', 0)
            # STT (per transaction)
            total += comps.get('stt', 0)
            # GST
            total += comps.get('gst', 0)
            return total
        else:
            return 0

    def _apply_stop_loss(self, position: Dict, current_price: float) -> Optional[float]:
        """Check and apply stop loss"""
        sl_config = self.risk_config.get('sl', {})
        if not sl_config.get('enabled', False):
            return None

        entry_price = position['entry_price']
        direction = position['direction']
        sl_type = sl_config.get('type', 'points')
        sl_value = sl_config.get('value', 20)

        if direction == 'LONG':
            if sl_type == 'points':
                sl_price = entry_price - sl_value
            elif sl_type == 'percent':
                sl_price = entry_price * (1 - sl_value / 100)
            else:  # atr
                sl_price = position.get('atr_sl', entry_price - sl_value)

            if current_price <= sl_price:
                return sl_price

        elif direction == 'SHORT':
            if sl_type == 'points':
                sl_price = entry_price + sl_value
            elif sl_type == 'percent':
                sl_price = entry_price * (1 + sl_value / 100)
            else:  # atr
                sl_price = position.get('atr_sl', entry_price + sl_value)

            if current_price >= sl_price:
                return sl_price

        return None

    def _apply_take_profit(self, position: Dict, current_price: float) -> Optional[float]:
        """Check and apply take profit"""
        tp_config = self.risk_config.get('tp', {})
        if not tp_config.get('enabled', False):
            return None

        entry_price = position['entry_price']
        direction = position['direction']
        tp_type = tp_config.get('type', 'points')
        tp_value = tp_config.get('value', 50)

        if direction == 'LONG':
            if tp_type == 'points':
                tp_price = entry_price + tp_value
            else:  # percent
                tp_price = entry_price * (1 + tp_value / 100)

            if current_price >= tp_price:
                # Check for lock-at-TP
                if tp_config.get('lockAtTp', False):
                    position['tp_locked'] = True
                    position['locked_price'] = current_price
                return tp_price

        elif direction == 'SHORT':
            if tp_type == 'points':
                tp_price = entry_price - tp_value
            else:  # percent
                tp_price = entry_price * (1 - tp_value / 100)

            if current_price <= tp_price:
                if tp_config.get('lockAtTp', False):
                    position['tp_locked'] = True
                    position['locked_price'] = current_price
                return tp_price

        return None

    def _apply_trailing_stop(self, position: Dict, current_price: float) -> Optional[float]:
        """Check and apply trailing stop loss"""
        tsl_config = self.risk_config.get('tsl', {})
        if not tsl_config.get('enabled', False):
            return None

        # Check if TSL should only apply after TP lock
        if tsl_config.get('afterTpLock', False) and not position.get('tp_locked', False):
            return None

        direction = position['direction']
        offset = tsl_config.get('offset', 50)

        if direction == 'LONG':
            position['highest_price'] = max(position.get('highest_price', current_price), current_price)
            tsl_price = position['highest_price'] - offset
            if current_price <= tsl_price:
                return tsl_price

        elif direction == 'SHORT':
            position['lowest_price'] = min(position.get('lowest_price', current_price), current_price)
            tsl_price = position['lowest_price'] + offset
            if current_price >= tsl_price:
                return tsl_price

        return None

    def _close_position(
        self,
        position: Dict,
        close_price: float,
        close_time: datetime,
        close_reason: str,
    ) -> TradeData:
        """Close a position and record the trade"""
        direction = position['direction']
        entry_price = position['entry_price']
        quantity = position['quantity']

        # Calculate P&L
        if direction == 'LONG':
            gross_pnl = (close_price - entry_price) * quantity
        else:  # SHORT
            gross_pnl = (entry_price - close_price) * quantity

        charges = self._calculate_charges(entry_price, close_price, quantity)
        net_pnl = gross_pnl - charges

        # Update equity
        self.current_equity += net_pnl

        # Record trade
        trade = TradeData(
            entry_time=position['entry_time'],
            entry_price=entry_price,
            direction=direction,
            quantity=quantity,
            exit_time=close_time,
            exit_price=close_price,
            exit_reason=close_reason,
            profit_loss=net_pnl,
            charges=charges,
        )
        self.trades.append(trade)

        # Update equity tracking
        self.highest_equity = max(self.highest_equity, self.current_equity)
        self.lowest_equity = min(self.lowest_equity, self.current_equity)

        return trade

    def run(self, start_date: date, end_date: date) -> Dict[str, Any]:
        """
        Run backtest for all symbols across date range.
        
        Returns:
            {
                'trades': List[Dict],
                'equity_curve': List[Dict],
                'summary': {...}
            }
        """
        logger.info(f"Starting DSL backtest {start_date} to {end_date}")

        # For now, support single symbol
        symbol = self.symbols[0]
        df = self.fetch_candles(symbol, start_date, end_date)

        if df.empty:
            logger.warning("No candles for backtest")
            return self._empty_result()

        # Reset state
        self.trades = []
        self.equity_curve = []
        self.current_equity = self.initial_capital
        self.positions = {}
        self.highest_equity = self.initial_capital
        self.lowest_equity = self.initial_capital

        # Record initial equity
        first_time = pd.Timestamp(df.index[0]).to_pydatetime()
        self.equity_curve.append({'time': first_time.isoformat(), 'equity': self.current_equity})

        # Prepare bars for compiled strategy evaluation
        bars = []
        for idx, (time, row) in enumerate(df.iterrows()):
            bar = {
                'time': pd.Timestamp(time).to_pydatetime(),
                'open': float(row.get('open', 0)),
                'high': float(row.get('high', 0)),
                'low': float(row.get('low', 0)),
                'close': float(row.get('close', 0)),
                'volume': float(row.get('volume', 0)),
            }
            bars.append(bar)

        # Run strategy evaluation on each bar
        for bar_idx, bar in enumerate(bars):
            # Evaluate strategy (returns entry/exit signals)
            try:
                signal = self.compiled_strategy['evaluate'](bar_idx, bars, {})
            except Exception as exc:
                logger.error(f"Error evaluating strategy at bar {bar_idx}: {exc}")
                signal = {'entrySignal': None, 'exitSignal': False}

            entry_signal = signal.get('entrySignal')  # 'LONG', 'SHORT', or None
            exit_signal = signal.get('exitSignal', False)  # Boolean

            # Check exit first
            if symbol in self.positions and exit_signal:
                position = self.positions[symbol]
                self._close_position(position, bar['close'], bar['time'], 'EXIT_SIGNAL')
                del self.positions[symbol]

            # Check stop loss / take profit
            if symbol in self.positions:
                position = self.positions[symbol]

                # Check stop loss
                sl_triggered = self._apply_stop_loss(position, bar['close'])
                if sl_triggered:
                    self._close_position(position, sl_triggered, bar['time'], 'STOP_LOSS')
                    del self.positions[symbol]
                    continue

                # Check take profit
                tp_triggered = self._apply_take_profit(position, bar['close'])
                if tp_triggered:
                    self._close_position(position, tp_triggered, bar['time'], 'TAKE_PROFIT')
                    del self.positions[symbol]
                    continue

                # Check trailing stop
                tsl_triggered = self._apply_trailing_stop(position, bar['close'])
                if tsl_triggered:
                    self._close_position(position, tsl_triggered, bar['time'], 'TRAILING_STOP')
                    del self.positions[symbol]
                    continue

            # Check entry signals
            if entry_signal and symbol not in self.positions:
                quantity = self._calculate_position_size(bar['close'], bar_idx)

                position = {
                    'direction': entry_signal,
                    'entry_price': bar['close'],
                    'entry_time': bar['time'],
                    'quantity': quantity,
                    'highest_price': bar['close'],
                    'lowest_price': bar['close'],
                    'tp_locked': False,
                }
                self.positions[symbol] = position

            # Record equity
            self.equity_curve.append({'time': bar['time'].isoformat(), 'equity': self.current_equity})

        # Close remaining positions at end
        if symbol in self.positions:
            last_bar = bars[-1]
            position = self.positions[symbol]
            self._close_position(position, last_bar['close'], last_bar['time'], 'END_OF_BACKTEST')

        # Calculate summary
        return self._build_result()

    def _build_result(self) -> Dict[str, Any]:
        """Build backtest result"""
        total_trades = len(self.trades)
        winning_trades = [t for t in self.trades if t.profit_loss > 0]
        losing_trades = [t for t in self.trades if t.profit_loss < 0]

        win_rate = len(winning_trades) / total_trades if total_trades > 0 else 0
        gross_profit = sum(t.profit_loss + t.charges for t in winning_trades)
        gross_loss = sum(t.profit_loss - t.charges for t in losing_trades)
        profit_factor = abs(gross_profit / gross_loss) if gross_loss != 0 else 0

        max_drawdown = 0
        if self.initial_capital > 0 and self.lowest_equity > 0:
            max_drawdown = (self.initial_capital - self.lowest_equity) / self.initial_capital

        total_pnl = self.current_equity - self.initial_capital
        total_charges = sum(t.charges for t in self.trades)

        return {
            'trades': [t.to_dict() for t in self.trades],
            'equity_curve': self.equity_curve,
            'summary': {
                'total_trades': total_trades,
                'winning_trades': len(winning_trades),
                'losing_trades': len(losing_trades),
                'win_rate': win_rate,
                'profit_factor': profit_factor,
                'total_pnl': total_pnl,
                'total_charges': total_charges,
                'max_drawdown': max_drawdown,
                'final_equity': self.current_equity,
                'roi': (total_pnl / self.initial_capital * 100) if self.initial_capital > 0 else 0,
            },
        }

    def _empty_result(self) -> Dict[str, Any]:
        """Return empty result"""
        return {
            'trades': [],
            'equity_curve': [{'time': datetime.now().isoformat(), 'equity': self.initial_capital}],
            'summary': {
                'total_trades': 0,
                'winning_trades': 0,
                'losing_trades': 0,
                'win_rate': 0,
                'profit_factor': 0,
                'total_pnl': 0,
                'total_charges': 0,
                'max_drawdown': 0,
                'final_equity': self.initial_capital,
                'roi': 0,
            },
        }
